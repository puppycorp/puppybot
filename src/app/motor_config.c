#include "motor_config.h"
#include "log.h"
#include "motor_hw.h"
#include "motor_runtime.h"
#include "motor_slots.h"
#include "pbcl.h"
#include "pbcl_motor_handler.h"
#include "platform.h"
#include "timer.h"
#include <string.h>

#define TAG "MOTOR_CONFIG"
#define MOTOR_TICK_INTERVAL_MS 5

// Global motor tick timer
static platform_timer_handle_t motor_tick_timer = NULL;

// Built-in PBCL configuration matching the default server profile.
// Allows the firmware to control drive motors and four servos before
// a remote ApplyConfig command arrives.
static const uint8_t k_default_motor_blob[] = {
    0x4c, 0x43, 0x42, 0x50, 0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x14, 0x00,
    0x15, 0x01, 0x00, 0x00, 0x56, 0x8e, 0x3c, 0x75, 0x01, 0x00, 0x03, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0a, 0x00,
    0x64, 0x72, 0x69, 0x76, 0x65, 0x5f, 0x6c, 0x65, 0x66, 0x74, 0x0a, 0x00,
    0x0c, 0x00, 0x21, 0x00, 0xe8, 0x03, 0xe8, 0x03, 0xd0, 0x07, 0x00, 0x00,
    0x00, 0x00, 0x0b, 0x00, 0x04, 0x00, 0x19, 0x1a, 0x00, 0x00, 0x01, 0x00,
    0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x0b, 0x00, 0x64, 0x72, 0x69, 0x76, 0x65, 0x5f, 0x72, 0x69, 0x67, 0x68,
    0x74, 0x0a, 0x00, 0x0c, 0x00, 0x20, 0x01, 0xe8, 0x03, 0xe8, 0x03, 0xd0,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x04, 0x00, 0x1b, 0x0e, 0x00,
    0x00, 0x01, 0x00, 0x01, 0x00, 0x64, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x07, 0x00, 0x73, 0x65, 0x72, 0x76, 0x6f, 0x5f, 0x30,
    0x0a, 0x00, 0x0c, 0x00, 0x0d, 0x02, 0x32, 0x00, 0xe8, 0x03, 0xd0, 0x07,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x65, 0x00, 0x00, 0x00,
    0x1b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x73, 0x65, 0x72, 0x76,
    0x6f, 0x5f, 0x31, 0x0a, 0x00, 0x0c, 0x00, 0x15, 0x03, 0x32, 0x00, 0xe8,
    0x03, 0xd0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x66,
    0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x73,
    0x65, 0x72, 0x76, 0x6f, 0x5f, 0x32, 0x0a, 0x00, 0x0c, 0x00, 0x16, 0x04,
    0x32, 0x00, 0xe8, 0x03, 0xd0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x01, 0x00, 0x67, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x07, 0x00, 0x73, 0x65, 0x72, 0x76, 0x6f, 0x5f, 0x33, 0x0a, 0x00, 0x0c,
    0x00, 0x17, 0x05, 0x32, 0x00, 0xe8, 0x03, 0xd0, 0x07, 0x00, 0x00, 0x00,
    0x00};

// Motor tick callback - called periodically by platform timer
static void motor_tick_callback(void *arg) {
	(void)arg;
	uint32_t now = platform_get_time_ms();
	motor_tick_all(now);
}

int motor_system_init(void) {
	// Initialize hardware
	motor_hw_init();

	// Create motor tick timer (5ms interval)
	motor_tick_timer = platform_timer_create(motor_tick_callback, NULL,
	                                         MOTOR_TICK_INTERVAL_MS);
	if (!motor_tick_timer) {
		log_error(TAG, "Failed to create motor tick timer");
		return -1;
	}

	// Start the tick timer
	if (platform_timer_start(motor_tick_timer) != 0) {
		log_error(TAG, "Failed to start motor tick timer");
		platform_timer_delete(motor_tick_timer);
		motor_tick_timer = NULL;
		return -1;
	}

	// Load default motor configuration if none exists
	if (motor_count() == 0) {
		int rc = motor_config_apply_default();
		if (rc != 0) {
			log_warn(TAG, "Failed to load built-in motor config (%d)", rc);
		}
	}

	return 0;
}

void motor_system_shutdown(void) {
	if (motor_tick_timer) {
		platform_timer_stop(motor_tick_timer);
		platform_timer_delete(motor_tick_timer);
		motor_tick_timer = NULL;
	}
	motor_config_reset();
}

void motor_config_reset(void) {
	motor_registry_clear();
	motor_slots_reset();
}

static int apply_sections(const pbcl_doc_t *doc) {
	const pbcl_sec_t *sec = pbcl_doc_first_section(doc);
	while (sec) {
		const uint8_t *payload = pbcl_section_payload(doc, sec, NULL);
		if (!payload)
			return -1;
		if (sec->class_id == PBCL_CLASS_MOTOR) {
			int rc = pbcl_apply_motor_section(sec, payload, sec->tlv_len);
			if (rc != 0)
				return rc;
		}
		sec = pbcl_doc_next_section(doc, sec);
	}
	return 0;
}

int motor_config_apply_blob(const uint8_t *blob, size_t len) {
	if (!blob || len == 0)
		return -1;

	pbcl_doc_t doc;
	pbcl_status_t st = pbcl_parse(blob, len, &doc);
	if (st != PBCL_OK) {
		log_error(TAG, "pbcl_parse failed (%d)", (int)st);
		return -2;
	}

	motor_config_reset();

	int rc = apply_sections(&doc);
	if (rc != 0)
		return rc;

	// Stop all drive motors
	for (int i = 0; i < motor_slots_drive_count(); ++i) {
		motor_rt_t *m = motor_slots_drive(i);
		if (m)
			motor_stop(m->node_id);
	}

	// Set all servos to boot angle
	int servo_count = motor_slots_servo_count();
	for (int i = 0; i < servo_count; ++i) {
		float boot = motor_slots_servo_boot_angle(i);
		motor_rt_t *m = motor_slots_servo(i);
		if (m)
			motor_set_angle(m->node_id, boot);
	}

	log_info(TAG, "Loaded %d motors (%d drive, %d servo)", motor_count(),
	         motor_slots_drive_count(), motor_slots_servo_count());
	return 0;
}

int motor_config_apply_default(void) {
	return motor_config_apply_blob(k_default_motor_blob,
	                               sizeof(k_default_motor_blob));
}

uint32_t motor_config_servo_count(void) {
	return (uint32_t)motor_slots_servo_count();
}
